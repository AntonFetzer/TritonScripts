import numpy as np
import matplotlib.pyplot as plt
from GRAS.Read.ReadLETHistos import readLETHistos
import sys
import os

def totalLETHistos(path):
    """
    Accumulates and processes GRAS LEThistos from multiple files.

    Args:
        path (str): The path to the folder containing the csv files.

    Returns:
        dict: A dictionary containing the accumulated LEThistos.

    Raises:
        SystemExit: If no files are found in the specified path.
        SystemExit: If the histogram bins in a file do not match the bins in the first file.

    """
    print("\nReading in all csv files in folder:", path)

    # Get list of all csv files in Path
    Files = [f for f in os.listdir(path) if "LET" in f and f.endswith(".csv")]

    NumFiles = len(Files)
    print("Number of Files:", NumFiles)

    if not Files:
        sys.exit("ERROR !!! No files found")

    # Initialize TotalLETHist for accumulation with zeros or appropriate structures
    # Since we don't have data yet, we'll initialize with None and set appropriately on first read
    TotalLETHist = {'lower': None, 'upper': None, 'mean': None, 'value': None, 'error': None, 'entries': None}

    # List to count how often a bin contained non-zero 'mean' values
    MeanCountList = None
    
    for File in Files:
        LETHistDict, _ = readLETHistos(os.path.join(path, File))
        
        # Initialize TotalLETHist bin edges with the first file's data
        if TotalLETHist['lower'] is None:
            for key in ["lower", "upper"]:
                TotalLETHist[key] = LETHistDict[key]
            for key in ["mean", "value", "error", "entries"]:
                TotalLETHist[key] = np.zeros_like(LETHistDict[key], dtype=float)
            # Initialize MeanCountList with zero ints
            MeanCountList = np.zeros_like(LETHistDict['mean'], dtype=int)
        else:
            # Check if the histogram bins are aligned
            if not np.allclose(TotalLETHist['lower'], LETHistDict['lower']) or not np.allclose(TotalLETHist['upper'], LETHistDict['upper']):
                # Exit program with error message
                sys.exit(f"ERROR !!! Histogram bins in file {File} do not match the bins in the first file")

        # Accumulate the data
        TotalLETHist['value'] += LETHistDict['value']
        TotalLETHist['entries'] += LETHistDict['entries']
        TotalLETHist['error'] += np.square(LETHistDict['error'])

        # Accumulate 'mean' selectively
        # 'non_zero_means' is assigned a boolean array generated by comparing each element in 'LETHistDict['mean']' with 0.
        # This boolean array has True values at indices where the corresponding elements in 'LETHistDict['mean']' are non-zero,
        # and False values where they are zero. This operation leverages NumPy's element-wise comparison capabilities,
        # producing an array of the same shape as 'LETHistDict['mean']', but filled with boolean values.
        non_zero_means = LETHistDict['mean'] != 0
        # This line uses the boolean array 'non_zero_means' as an index to selectively update elements in 'TotalLETHist['mean']'.
        # Specifically, it adds values from 'LETHistDict['mean']' to 'TotalLETHist['mean']' only at positions where 'non_zero_means' is True.
        # The operation is element-wise and only affects the subset of 'TotalLETHist['mean']' corresponding to True values in 'non_zero_means'.
        # This technique, known as boolean indexing or masking, allows for conditional updating of an array based on another array of boolean values.
        TotalLETHist['mean'][non_zero_means] += LETHistDict['mean'][non_zero_means]
        # Similar to the previous operation, this line increments elements in 'MeanCountList' by 1, but only at positions where 'non_zero_means' is True.
        # It uses the same boolean array 'non_zero_means' for indexing, effectively counting the number of non-zero 'mean' values encountered for each bin.
        # This selective incrementing updates 'MeanCountList', which is also a NumPy array, at indices corresponding to non-zero entries in 'LETHistDict['mean']'.
        MeanCountList[non_zero_means] += 1
    
    # Final calculations after processing all files
        
    # Finalize 'mean' calculation
    # 'valid_means' is assigned a boolean array generated by comparing each element in 'MeanCountList' with 0.
    # This boolean array contains True values at indices where 'MeanCountList' has non-zero values, indicating bins 
    # that received at least one non-zero 'mean' value,
    # and False values where 'MeanCountList' is zero, indicating bins that never received a non-zero 'mean' value.
    # The comparison generates an array of boolean values, used to identify bins with valid data for averaging.
    valid_means = MeanCountList != 0
    # Using the boolean array 'valid_means' for indexing, this line divides elements in 'TotalLETHist['mean']' by their corresponding counts in 'MeanCountList',
    # but only for bins marked as valid by 'valid_means'. This operation calculates the average 'mean' value per bin, applying the averaging only to bins
    # that received non-zero 'mean' values. The division is performed element-wise on the subset of 'TotalLETHist['mean']' corresponding to True values in 'valid_means',
    # effectively finalizing the calculation of average 'mean' values for these bins.
    TotalLETHist['mean'][valid_means] /= MeanCountList[valid_means]

    TotalLETHist['value'] /= NumFiles
    TotalLETHist['error'] = np.sqrt(TotalLETHist['error']) / NumFiles
    
    return TotalLETHist

if __name__ == "__main__":

    # Only works if all input files have the same number of particle!!!!!
    path = "/l/triton_work/LET/Foresail1-Hercules/FS1-SolarProtons/0mm/Res/"

    LET = totalLETHistos(path)

    print("LETHist Shape", np.shape(LET))

    ### LET by Entries ###############
    # Calculate sums and total LET by entries for LETHist
    NumberEntriesLETHist = np.sum(LET['entries'])
    TotalLETbyEntries = np.sum(LET['mean'] * LET['entries'])

    # Plotting LET Histogram by entries
    plt.figure(0)
    plt.bar(LET['lower'], LET['entries'], width=LET['upper'] - LET['lower'], align='edge')
    plt.yscale("log")
    plt.xscale("log")
    plt.grid()
    plt.title("LET Histogram " + f"{NumberEntriesLETHist:.2e}" + " entries\nTotal LET by Entries " + f"{TotalLETbyEntries:.2e}" + " [MeV cm2 mg-1]")
    plt.xlabel("LET [MeV cm2 mg-1]")
    plt.ylabel("Number of entries per LET bin")

    plt.savefig(path + "../LET-Entries.png", dpi=300, bbox_inches='tight')

    # Calculate total LET by values for LETHist
    TotalLETbyValues = np.sum(LET['mean'] * LET['value'])

    # Plotting LET Histogram by values and error bars
    plt.figure(1)
    plt.bar(LET['lower'], LET['value'], width=LET['upper'] - LET['lower'], align='edge', alpha=0.3)
    plt.errorbar(LET['mean'], LET['value'], LET['error'], fmt=' ', capsize=5, elinewidth=1, capthick=1, label="LET Histogram")
    plt.yscale("log")
    plt.xscale("log")
    plt.grid()
    plt.title("LET Histogram " + f"{NumberEntriesLETHist:.2e}" + " entries\nTotal LET by Values " + f"{TotalLETbyValues:.2e}" + " [MeV cm2 mg-1]")
    plt.xlabel("LET [MeV cm2 mg-1]")
    plt.ylabel("Rate per LET bin [cm-2 s-1]")

    plt.savefig(path + "../LET-Values.png", dpi=300, bbox_inches='tight')

    # plt.show()
